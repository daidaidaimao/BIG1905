#ConcurrentMap -并发映射
##概述
**1.本质上是一个map，依然以剑指队的结构来存储数据
2.ConcurrentMap提供了并发且安全的方式来读写教程**
##ConcurrentHashMap 并发哈希映射
1.底层结构是基于数组+链表存储，默认初始容量16，默认加载因子0.75，每次扩容默认增加一倍

2.ConcurrentHashMap 是一个异步式线程安全映射,在其中引入了分段锁机制来解决效率降低的问题，在后续JDK版本中，
concurrentHashMap在分段锁的基础上引入了`读写锁`来提高效率
####a.读锁： 允许多个线程读，不允许线程写
####b.写锁 ：只允许一个县城写，不允许线程读

3.在JDK1.8中，ConcurrentHashMap引入了`CAS算法(Compare And Swap)`保证异步线程安全，摒弃了锁。
`CAS算法`需要与具体的内核结合，目前几乎所有的内核架构都是`支持CAS`

###### CAS语义：我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少 
###### V：内存值 A：旧的预期值 B：新的预期值

4.在JDK1.8中，ConcurrentHashMap引入了红黑树...当桶中的元素个数超过8个的时候，桶中的链表会扭成一棵红黑树，如果红黑树的节点个数不超过7个
那么红黑树会扭转回链表

5.红黑树:
    a.本质平衡是二叉查找树
    b.二叉查找树的特点
    c.红黑树的特点：
        1.所有的节点的颜色非红即黑
        2.根节点必须是黑节点
        3.红下为黑

`HashTable对外提供的方法都是非静态方法--同步非静态方法的锁对象是
this-- this表示当前对象--HashTable是以当前对象作为锁对象`

##ConcurrentNavigableMap    并发导航映射
1.这个映射中提供了用于截取子映射的方法

2.ConcurrentNavigableMap本身是一个接口，所以通常使用它的实现类`ConcurrentSkipListMap--并发跳跃表映射`

ConcurrentSkipListMap底层是基于了跳跃表实现的

3.跳跃表：
    a.要求元素必须有序
    b.跳跃表必须形成多层，但是最上层的跳跃表中的元素个数至少2个
    c.跳跃表适合查询多的场景
    d.跳跃表本身是一个典型的以空间换时间的产物
    e.在跳跃表中如果新增节点，这个基点是否要提取到上层的跳跃表中，遵循抛硬币原则，
    f.跳跃表的时间复杂度o(logn)